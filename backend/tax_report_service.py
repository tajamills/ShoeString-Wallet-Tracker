"""
Tax Report Service - Generates IRS Form 8949, Schedule D, and other tax reports
"""
import logging
from typing import Dict, List, Any, Optional
from datetime import datetime
import csv
import io

logger = logging.getLogger(__name__)

# Transaction category constants
TRANSACTION_CATEGORIES = {
    'trade': {'label': 'Trade', 'taxable': True, 'type': 'capital_gains'},
    'income': {'label': 'Income', 'taxable': True, 'type': 'ordinary_income'},
    'gift_received': {'label': 'Gift Received', 'taxable': False, 'type': 'gift'},
    'gift_sent': {'label': 'Gift Sent', 'taxable': False, 'type': 'gift'},
    'payment': {'label': 'Payment', 'taxable': True, 'type': 'capital_gains'},
    'transfer': {'label': 'Transfer', 'taxable': False, 'type': 'non_taxable'},
    'lost': {'label': 'Lost/Stolen', 'taxable': True, 'type': 'capital_loss'},
    'fee': {'label': 'Fee', 'taxable': False, 'type': 'cost_basis'},
    'airdrop': {'label': 'Airdrop', 'taxable': True, 'type': 'ordinary_income'},
    'staking': {'label': 'Staking Reward', 'taxable': True, 'type': 'ordinary_income'},
    'mining': {'label': 'Mining Reward', 'taxable': True, 'type': 'ordinary_income'},
    'other': {'label': 'Other', 'taxable': True, 'type': 'unknown'}
}

class TaxReportService:
    """Service for generating tax reports including IRS Form 8949 and Schedule D"""
    
    def __init__(self):
        self.form_8949_headers = [
            'Description of property',
            'Date acquired',
            'Date sold or disposed',
            'Proceeds (sales price)',
            'Cost or other basis',
            'Gain or (loss)',
            'Holding period'
        ]
        
        # Tax years supported
        self.supported_tax_years = list(range(2020, datetime.now().year + 1))
    
    def filter_by_tax_year(
        self, 
        realized_gains: List[Dict[str, Any]], 
        tax_year: Optional[int] = None
    ) -> List[Dict[str, Any]]:
        """Filter realized gains by tax year based on sell date"""
        if not tax_year:
            return realized_gains
        
        filtered = []
        for gain in realized_gains:
            sell_date = gain.get('sell_date', '')
            if sell_date:
                try:
                    # Parse date and check year
                    if isinstance(sell_date, str):
                        year = int(sell_date.split('-')[0])
                        if year == tax_year:
                            filtered.append(gain)
                except (ValueError, IndexError):
                    # If can't parse date, include it
                    filtered.append(gain)
        return filtered
    
    def generate_schedule_d_summary(
        self,
        realized_gains: List[Dict[str, Any]],
        tax_year: int,
        symbol: str,
        address: str
    ) -> str:
        """
        Generate IRS Schedule D Summary (Capital Gains and Losses)
        
        Schedule D summarizes capital gains/losses from Form 8949
        and calculates the net capital gain/loss
        """
        try:
            output = io.StringIO()
            
            # Filter by tax year
            year_gains = self.filter_by_tax_year(realized_gains, tax_year)
            
            # Separate short-term and long-term
            short_term = [g for g in year_gains if g.get('holding_period') == 'short-term']
            long_term = [g for g in year_gains if g.get('holding_period') == 'long-term']
            
            # Calculate totals
            st_proceeds = sum(g.get('proceeds', 0) for g in short_term)
            st_cost_basis = sum(g.get('cost_basis', 0) for g in short_term)
            st_gain_loss = sum(g.get('gain_loss', 0) for g in short_term)
            
            lt_proceeds = sum(g.get('proceeds', 0) for g in long_term)
            lt_cost_basis = sum(g.get('cost_basis', 0) for g in long_term)
            lt_gain_loss = sum(g.get('gain_loss', 0) for g in long_term)
            
            total_proceeds = st_proceeds + lt_proceeds
            total_cost_basis = st_cost_basis + lt_cost_basis
            net_gain_loss = st_gain_loss + lt_gain_loss
            
            # Header
            output.write('=' * 70 + '\n')
            output.write('IRS SCHEDULE D (Form 1040) - Capital Gains and Losses\n')
            output.write('=' * 70 + '\n')
            output.write(f'Tax Year: {tax_year}\n')
            output.write(f'Generated by Crypto Bag Tracker\n')
            output.write(f'Wallet: {address[:10]}...{address[-6:]}\n')
            output.write(f'Asset: {symbol}\n')
            output.write(f'Generated: {datetime.now().strftime("%Y-%m-%d %H:%M:%S")}\n')
            output.write('=' * 70 + '\n\n')
            
            # Part I - Short-Term Capital Gains and Losses
            output.write('PART I - SHORT-TERM CAPITAL GAINS AND LOSSES\n')
            output.write('(Assets held one year or less)\n')
            output.write('-' * 50 + '\n')
            output.write(f'Number of transactions:    {len(short_term):>15}\n')
            output.write(f'Total Proceeds:            ${st_proceeds:>14,.2f}\n')
            output.write(f'Total Cost Basis:          ${st_cost_basis:>14,.2f}\n')
            output.write(f'Net Short-Term Gain/Loss:  ${st_gain_loss:>14,.2f}\n')
            output.write('\n')
            
            # Part II - Long-Term Capital Gains and Losses
            output.write('PART II - LONG-TERM CAPITAL GAINS AND LOSSES\n')
            output.write('(Assets held more than one year)\n')
            output.write('-' * 50 + '\n')
            output.write(f'Number of transactions:    {len(long_term):>15}\n')
            output.write(f'Total Proceeds:            ${lt_proceeds:>14,.2f}\n')
            output.write(f'Total Cost Basis:          ${lt_cost_basis:>14,.2f}\n')
            output.write(f'Net Long-Term Gain/Loss:   ${lt_gain_loss:>14,.2f}\n')
            output.write('\n')
            
            # Part III - Summary
            output.write('PART III - SUMMARY\n')
            output.write('=' * 50 + '\n')
            output.write(f'Total Transactions:        {len(year_gains):>15}\n')
            output.write(f'Combined Proceeds:         ${total_proceeds:>14,.2f}\n')
            output.write(f'Combined Cost Basis:       ${total_cost_basis:>14,.2f}\n')
            output.write('-' * 50 + '\n')
            
            gain_loss_label = 'NET CAPITAL GAIN' if net_gain_loss >= 0 else 'NET CAPITAL LOSS'
            output.write(f'{gain_loss_label}:        ${abs(net_gain_loss):>14,.2f}\n')
            output.write('=' * 50 + '\n\n')
            
            # Tax implications note
            if net_gain_loss > 0:
                output.write('TAX NOTE: Net capital gains are taxable.\n')
                output.write('- Short-term gains are taxed as ordinary income.\n')
                output.write('- Long-term gains are taxed at preferential rates (0%, 15%, or 20%).\n')
            elif net_gain_loss < 0:
                output.write('TAX NOTE: Net capital losses can offset other income.\n')
                output.write(f'- Up to $3,000 of net capital loss can be deducted per year.\n')
                output.write(f'- Excess losses can be carried forward to future years.\n')
                carryforward = max(0, abs(net_gain_loss) - 3000)
                if carryforward > 0:
                    output.write(f'- Estimated carryforward to {tax_year + 1}: ${carryforward:,.2f}\n')
            
            output.write('\n')
            output.write('DISCLAIMER: This is an informational summary only.\n')
            output.write('Consult a qualified tax professional for advice.\n')
            
            return output.getvalue()
            
        except Exception as e:
            logger.error(f"Error generating Schedule D: {str(e)}")
            raise Exception(f"Failed to generate Schedule D: {str(e)}")
    
    def generate_schedule_d_csv(
        self,
        realized_gains: List[Dict[str, Any]],
        tax_year: int,
        symbol: str,
        address: str
    ) -> str:
        """Generate Schedule D summary as CSV for import into tax software"""
        try:
            output = io.StringIO()
            writer = csv.writer(output)
            
            # Filter by tax year
            year_gains = self.filter_by_tax_year(realized_gains, tax_year)
            
            # Separate and calculate
            short_term = [g for g in year_gains if g.get('holding_period') == 'short-term']
            long_term = [g for g in year_gains if g.get('holding_period') == 'long-term']
            
            # Header info
            writer.writerow(['Schedule D Summary', f'Tax Year {tax_year}'])
            writer.writerow(['Generated by', 'Crypto Bag Tracker'])
            writer.writerow(['Wallet', address])
            writer.writerow(['Asset', symbol])
            writer.writerow(['Generated Date', datetime.now().strftime('%Y-%m-%d')])
            writer.writerow([])
            
            # Summary table
            writer.writerow(['Category', 'Transactions', 'Proceeds', 'Cost Basis', 'Gain/Loss'])
            
            st_data = [
                'Short-Term',
                len(short_term),
                sum(g.get('proceeds', 0) for g in short_term),
                sum(g.get('cost_basis', 0) for g in short_term),
                sum(g.get('gain_loss', 0) for g in short_term)
            ]
            writer.writerow(st_data)
            
            lt_data = [
                'Long-Term',
                len(long_term),
                sum(g.get('proceeds', 0) for g in long_term),
                sum(g.get('cost_basis', 0) for g in long_term),
                sum(g.get('gain_loss', 0) for g in long_term)
            ]
            writer.writerow(lt_data)
            
            total_data = [
                'TOTAL',
                len(year_gains),
                st_data[2] + lt_data[2],
                st_data[3] + lt_data[3],
                st_data[4] + lt_data[4]
            ]
            writer.writerow(total_data)
            
            return output.getvalue()
            
        except Exception as e:
            logger.error(f"Error generating Schedule D CSV: {str(e)}")
            raise Exception(f"Failed to generate Schedule D CSV: {str(e)}")
    
    def batch_categorize_transactions(
        self,
        transactions: List[Dict[str, Any]],
        rules: List[Dict[str, Any]]
    ) -> Dict[str, str]:
        """
        Batch categorize transactions based on rules
        
        Rules format:
        [
            {'type': 'address', 'value': '0x...', 'category': 'transfer'},
            {'type': 'amount_gt', 'value': 10, 'category': 'trade'},
            {'type': 'tx_type', 'value': 'received', 'category': 'income'},
        ]
        
        Returns: Dict of tx_hash -> category
        """
        categories = {}
        
        for tx in transactions:
            tx_hash = tx.get('hash')
            if not tx_hash:
                continue
            
            # Default category
            category = 'other'
            
            # Apply rules in order (first match wins)
            for rule in rules:
                rule_type = rule.get('type')
                rule_value = rule.get('value')
                rule_category = rule.get('category')
                
                matched = False
                
                if rule_type == 'address':
                    # Match by to/from address
                    if tx.get('to', '').lower() == rule_value.lower() or \
                       tx.get('from', '').lower() == rule_value.lower():
                        matched = True
                        
                elif rule_type == 'amount_gt':
                    # Match by amount greater than
                    if float(tx.get('value', 0)) > float(rule_value):
                        matched = True
                        
                elif rule_type == 'amount_lt':
                    # Match by amount less than
                    if float(tx.get('value', 0)) < float(rule_value):
                        matched = True
                        
                elif rule_type == 'tx_type':
                    # Match by transaction type (sent/received)
                    if tx.get('type', '').lower() == rule_value.lower():
                        matched = True
                        
                elif rule_type == 'asset':
                    # Match by asset
                    if tx.get('asset', '').upper() == rule_value.upper():
                        matched = True
                
                if matched:
                    category = rule_category
                    break
            
            categories[tx_hash] = category
        
        return categories
    
    def auto_categorize_transactions(
        self,
        transactions: List[Dict[str, Any]],
        known_addresses: Optional[Dict[str, str]] = None
    ) -> Dict[str, str]:
        """
        Auto-categorize transactions using smart detection
        
        known_addresses: Dict of address -> label (e.g., 'exchange', 'defi', 'self')
        """
        categories = {}
        known_addresses = known_addresses or {}
        
        # Common exchange addresses (simplified list)
        exchange_addresses = {
            '0x': 'exchange'  # Would be populated with real exchange addresses
        }
        
        for tx in transactions:
            tx_hash = tx.get('hash')
            if not tx_hash:
                continue
            
            tx_type = tx.get('type', 'unknown')
            to_addr = tx.get('to', '').lower()
            from_addr = tx.get('from', '').lower()
            value = float(tx.get('value', 0))
            
            # Default to trade
            category = 'trade'
            
            # Check for transfers (to own addresses)
            if to_addr in known_addresses and known_addresses[to_addr] == 'self':
                category = 'transfer'
            elif from_addr in known_addresses and known_addresses[from_addr] == 'self':
                category = 'transfer'
            
            # Check for small amounts (likely fees or dust)
            elif value < 0.0001:
                category = 'fee'
            
            # Check for exchange addresses
            elif to_addr in exchange_addresses or from_addr in exchange_addresses:
                category = 'trade'
            
            # Received transactions might be income
            elif tx_type == 'received' and from_addr in known_addresses:
                label = known_addresses[from_addr]
                if label in ['staking', 'mining', 'airdrop']:
                    category = label
            
            categories[tx_hash] = category
        
        return categories
    
    def generate_form_8949_csv(
        self,
        realized_gains: List[Dict[str, Any]],
        symbol: str,
        address: str,
        filter_type: str = 'all'
    ) -> str:
        """
        Generate IRS Form 8949 compatible CSV
        
        Args:
            realized_gains: List of realized gain transactions
            symbol: Cryptocurrency symbol (ETH, BTC, etc.)
            address: Wallet address
            filter_type: 'all', 'short-term', or 'long-term'
        
        Returns:
            CSV content as string
        """
        try:
            output = io.StringIO()
            
            # Filter by holding period if specified
            filtered_gains = realized_gains
            if filter_type == 'short-term':
                filtered_gains = [g for g in realized_gains if g.get('holding_period') == 'short-term']
            elif filter_type == 'long-term':
                filtered_gains = [g for g in realized_gains if g.get('holding_period') == 'long-term']
            
            # Write header information
            output.write('IRS Form 8949 - Sales and Other Dispositions of Capital Assets\n')
            output.write(f'Generated by Crypto Bag Tracker\n')
            output.write(f'Wallet Address: {address}\n')
            output.write(f'Asset: {symbol}\n')
            output.write(f'Generated: {datetime.now().strftime("%Y-%m-%d %H:%M:%S")}\n')
            output.write(f'Filter: {filter_type.replace("-", " ").title()}\n')
            output.write('\n')
            
            # Determine which part of Form 8949 this goes in
            if filter_type == 'short-term':
                output.write('Part I - Short-term capital gains and losses (assets held one year or less)\n')
                output.write('Check Box A, B, or C per IRS instructions\n')
            elif filter_type == 'long-term':
                output.write('Part II - Long-term capital gains and losses (assets held more than one year)\n')
                output.write('Check Box D, E, or F per IRS instructions\n')
            else:
                output.write('Combined Short-term and Long-term Report\n')
            
            output.write('\n')
            
            # Write CSV data
            writer = csv.writer(output)
            writer.writerow(self.form_8949_headers)
            
            total_proceeds = 0
            total_cost_basis = 0
            total_gain_loss = 0
            
            for gain in filtered_gains:
                description = f"{gain.get('amount', 0):.8f} {symbol}"
                date_acquired = gain.get('buy_date', 'Various')
                date_sold = gain.get('sell_date', 'Unknown')
                proceeds = gain.get('proceeds', 0)
                cost_basis = gain.get('cost_basis', 0)
                gain_loss = gain.get('gain_loss', 0)
                holding_period = gain.get('holding_period', 'unknown')
                
                writer.writerow([
                    description,
                    date_acquired,
                    date_sold,
                    f'{proceeds:.2f}',
                    f'{cost_basis:.2f}',
                    f'{gain_loss:.2f}',
                    holding_period.title()
                ])
                
                total_proceeds += proceeds
                total_cost_basis += cost_basis
                total_gain_loss += gain_loss
            
            # Write totals
            output.write('\n')
            writer.writerow([
                'TOTALS',
                '',
                '',
                f'{total_proceeds:.2f}',
                f'{total_cost_basis:.2f}',
                f'{total_gain_loss:.2f}',
                ''
            ])
            
            # Add summary
            output.write('\n')
            output.write(f'Total Transactions: {len(filtered_gains)}\n')
            output.write(f'Total Proceeds: ${total_proceeds:.2f}\n')
            output.write(f'Total Cost Basis: ${total_cost_basis:.2f}\n')
            output.write(f'Net Gain/(Loss): ${total_gain_loss:.2f}\n')
            
            # Add disclaimer
            output.write('\n')
            output.write('DISCLAIMER: This report is generated for informational purposes only.\n')
            output.write('Consult a qualified tax professional for advice specific to your situation.\n')
            output.write('Crypto Bag Tracker is not responsible for any errors or omissions.\n')
            
            return output.getvalue()
            
        except Exception as e:
            logger.error(f"Error generating Form 8949: {str(e)}")
            raise Exception(f"Failed to generate Form 8949: {str(e)}")
    
    def generate_tax_summary_csv(
        self,
        tax_data: Dict[str, Any],
        symbol: str,
        address: str
    ) -> str:
        """Generate comprehensive tax summary CSV"""
        try:
            output = io.StringIO()
            
            summary = tax_data.get('summary', {})
            realized = tax_data.get('realized_gains', [])
            unrealized = tax_data.get('unrealized_gains', {})
            
            # Header
            output.write('Crypto Bag Tracker - Tax Summary Report\n')
            output.write(f'Wallet Address: {address}\n')
            output.write(f'Asset: {symbol}\n')
            output.write(f'Method: {tax_data.get("method", "FIFO")}\n')
            output.write(f'Generated: {datetime.now().strftime("%Y-%m-%d %H:%M:%S")}\n')
            output.write('\n')
            
            # Summary Section
            output.write('=== SUMMARY ===\n')
            output.write(f'Total Realized Gains/Losses: ${summary.get("total_realized_gain", 0):.2f}\n')
            output.write(f'  - Short-term: ${summary.get("short_term_gains", 0):.2f}\n')
            output.write(f'  - Long-term: ${summary.get("long_term_gains", 0):.2f}\n')
            output.write(f'Total Unrealized Gains: ${summary.get("total_unrealized_gain", 0):.2f}\n')
            output.write(f'Total Transactions: {summary.get("total_transactions", 0)}\n')
            output.write(f'  - Buys: {summary.get("buy_count", 0)}\n')
            output.write(f'  - Sells: {summary.get("sell_count", 0)}\n')
            output.write('\n')
            
            # Holdings Section
            if unrealized:
                output.write('=== CURRENT HOLDINGS ===\n')
                output.write(f'Total Cost Basis: ${unrealized.get("total_cost_basis", 0):.2f}\n')
                output.write(f'Current Market Value: ${unrealized.get("total_current_value", 0):.2f}\n')
                output.write(f'Unrealized Gain/Loss: ${unrealized.get("total_gain", 0):.2f}\n')
                output.write(f'Return: {unrealized.get("total_gain_percentage", 0):.2f}%\n')
            
            output.write('\n')
            output.write('=== DETAILED TRANSACTIONS ===\n')
            
            # Realized gains detail
            writer = csv.writer(output)
            writer.writerow([
                'Type', 'Buy Date', 'Sell Date', 'Amount', 
                'Buy Price', 'Sell Price', 'Cost Basis', 
                'Proceeds', 'Gain/Loss', 'Holding Period'
            ])
            
            for gain in realized:
                writer.writerow([
                    'Disposition',
                    gain.get('buy_date', ''),
                    gain.get('sell_date', ''),
                    f"{gain.get('amount', 0):.8f}",
                    f"{gain.get('buy_price', 0):.2f}",
                    f"{gain.get('sell_price', 0):.2f}",
                    f"{gain.get('cost_basis', 0):.2f}",
                    f"{gain.get('proceeds', 0):.2f}",
                    f"{gain.get('gain_loss', 0):.2f}",
                    gain.get('holding_period', 'unknown')
                ])
            
            return output.getvalue()
            
        except Exception as e:
            logger.error(f"Error generating tax summary: {str(e)}")
            raise Exception(f"Failed to generate tax summary: {str(e)}")
    
    def categorize_transaction(
        self,
        tx: Dict[str, Any],
        category: str
    ) -> Dict[str, Any]:
        """
        Apply category to transaction for tax purposes
        
        Categories affect tax treatment:
        - trade: Taxable event, subject to capital gains
        - income: Ordinary income (mining, staking, airdrops)
        - gift_received: Cost basis = fair market value at time of gift
        - gift_sent: No tax event (but may have gift tax implications)
        - payment: Taxable at fair market value
        - transfer: Not a taxable event
        - lost: May be deductible as a capital loss
        - fee: Adds to cost basis
        """
        tx['category'] = category
        tx['tax_treatment'] = self._get_tax_treatment(category)
        return tx
    
    def _get_tax_treatment(self, category: str) -> Dict[str, Any]:
        """Get tax treatment based on category"""
        treatments = {
            'trade': {
                'taxable': True,
                'type': 'capital_gains',
                'description': 'Subject to capital gains tax'
            },
            'income': {
                'taxable': True,
                'type': 'ordinary_income',
                'description': 'Taxed as ordinary income at receipt'
            },
            'gift_received': {
                'taxable': False,
                'type': 'gift',
                'description': 'Not taxable; cost basis carries over or FMV'
            },
            'gift_sent': {
                'taxable': False,
                'type': 'gift',
                'description': 'No income tax; may have gift tax implications'
            },
            'payment': {
                'taxable': True,
                'type': 'capital_gains',
                'description': 'Taxable at fair market value'
            },
            'transfer': {
                'taxable': False,
                'type': 'non_taxable',
                'description': 'Not a taxable event'
            },
            'lost': {
                'taxable': True,
                'type': 'capital_loss',
                'description': 'May be deductible as capital loss'
            },
            'fee': {
                'taxable': False,
                'type': 'cost_basis',
                'description': 'Added to cost basis'
            },
            'other': {
                'taxable': True,
                'type': 'unknown',
                'description': 'Review and categorize properly'
            }
        }
        return treatments.get(category, treatments['other'])


# Initialize global service
tax_report_service = TaxReportService()
